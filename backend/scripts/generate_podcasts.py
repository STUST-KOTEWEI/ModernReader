"""Batch generate preview podcasts for books.

- If a book has no content, create a minimal single-chapter content from its
  summary or a language-specific stub.
- If TTS is configured (Azure), synthesize the first chapter audio and set
  podcast_url, so the frontend can stream it via the existing audio endpoint.

Usage:
  poetry run python backend/scripts/generate_podcasts.py

Optional environment variables (from app.core.config.Settings):
  - DATABASE_URL (defaults to sqlite:///./modernreader.db)
    - TTS_PROVIDER=azure and AZURE_SPEECH_KEY/AZURE_SPEECH_REGION
        required for TTS
"""
from __future__ import annotations

import sys
from pathlib import Path
from typing import Optional

# Ensure we can import `app.*`
ROOT = Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

from app.db.database import SessionLocal  # noqa: E402
from app.models.catalog import Book  # noqa: E402
from app.models.content import BookContent, BookChapter  # noqa: E402
from app.services.podcast import PodcastService  # noqa: E402


def _stub_text(title: str, language: str, summary: Optional[str]) -> str:
    if summary and summary.strip():
        base = summary.strip()
    else:
        if (language or "").startswith("zh"):
            base = (
                "這是一本由現代閱讀系統自動產生的示範內容。"
                "此章節僅供預覽與語音合成測試使用。"
            )
        elif (language or "").startswith("ja"):
            base = (
                "これは ModernReader によって自動生成されたサンプルコンテンツです。"
                "この章はプレビューと音声合成のテストのみを目的としています。"
            )
        else:
            base = (
                "This is a sample content automatically generated by "
                "ModernReader. This chapter is provided for preview and TTS "
                "testing only."
            )
    header = f"{title}\n\n"
    filler = (base + "\n\n") * 3  # make it long enough for audible preview
    return header + filler


def ensure_content_for_book(db, book: Book) -> BookContent:
    content = (
        db.query(BookContent)
        .filter(BookContent.book_id == book.id)
        .one_or_none()
    )
    if content:
        return content
    text = _stub_text(
        book.title or "Untitled", book.language or "en", book.summary
    )
    content = BookContent(
        book_id=book.id,
        full_text=text,
        content_hash="",  # optional; not used by batch script
        format="txt",
    )
    db.add(content)
    db.flush()
    # create a single preview chapter
    chapter = BookChapter(
        content_id=content.id,
        chapter_number=1,
        title="Introduction",
        text=text,
        word_count=len(text.split()),
        is_preview=True,
    )
    db.add(chapter)
    db.commit()
    return content


def ensure_podcast_for_preview(
    db, content: BookContent, svc: PodcastService
) -> int:
    # find preview chapter (first chapter fallback)
    chapter = (
        db.query(BookChapter)
        .filter(BookChapter.content_id == content.id)
        .order_by(BookChapter.chapter_number.asc())
        .first()
    )
    if not chapter:
        return 0
    if not svc.is_configured():
        # TTS not configured; skip gracefully
        return 0
    out_path = svc._chapter_filename(chapter)
    if not out_path.exists():
        svc.synthesize_chapter(chapter)
    if not chapter.podcast_url:
        chapter.podcast_url = f"/api/v1/catalog/chapters/{chapter.id}/audio"
        db.add(chapter)
        db.commit()
    return 1


def main() -> None:
    db = SessionLocal()
    try:
        svc = PodcastService()
        books = db.query(Book).order_by(Book.created_at.asc()).all()
        created_contents = 0
        generated_audio = 0
        for book in books:
            content = (
                db.query(BookContent)
                .filter(BookContent.book_id == book.id)
                .one_or_none()
            )
            if not content:
                content = ensure_content_for_book(db, book)
                created_contents += 1
            generated_audio += ensure_podcast_for_preview(db, content, svc)
        print(
            f"Done. contents_created={created_contents}, "
            f"preview_audios_generated={generated_audio}"
        )
    finally:
        db.close()


if __name__ == "__main__":
    main()
